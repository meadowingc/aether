{# Reusable note form partial. Expects variables: form_action, note_text, submit_label, show_save_draft, is_edit, errors, device_id, user, profile, crosspost fields, etc. #}
<form class="note-form" action="{{ form_action }}" method="post">
  {% csrf_token %}
  <label class="sr-only" for="note_text">Note</label>
  <textarea id="note_text" name="text" rows="3" maxlength="2000" placeholder="Go on, throw it into the voidâ€¦" required autocomplete="off">{{ note_text|default_if_none:"" }}</textarea>
  <div class="counter-row">
    <span id="note_counter" class="char-counter">0/2000</span>
    {% if user.is_authenticated and profile %}
      {% with p=profile %}
        <div class="network-counters">
          {% if p.crosspost_mastodon and p.mastodon_instance and p.mastodon_token %}
            <label class="net-toggle">
              <input type="checkbox" name="xp_mastodon" id="xp_mastodon" checked>
              <span>Mastodon</span>
              <span id="mastodon_counter" class="char-counter small" data-limit="{{ p.mastodon_char_limit|default:2000 }}">0/{{ p.mastodon_char_limit|default:2000 }}</span>
            </label>
          {% endif %}
          {% if p.crosspost_bluesky and p.bluesky_handle and p.bluesky_app_password %}
            <label class="net-toggle">
              <input type="checkbox" name="xp_bluesky" id="xp_bluesky" checked>
              <span>Bluesky</span>
              <span id="bluesky_counter" class="char-counter small" data-limit="300">0/300</span>
            </label>
          {% endif %}
          {% if p.crosspost_status_cafe and p.status_cafe_username and p.status_cafe_password %}
            <label class="net-toggle">
              <input type="checkbox" name="xp_status_cafe" id="xp_status_cafe" checked>
              <span>Status.cafe</span>
              <span id="status_cafe_counter" class="char-counter small" data-limit="140">0/140</span>
              <span class="face-picker-wrap" style="display:inline-flex; align-items:center; gap:4px;">
                <input type="hidden" name="xp_status_cafe_face" id="xp_status_cafe_face" value="">
                <button type="button" id="face_display_btn" class="face-emoji-btn" aria-haspopup="dialog" aria-expanded="false" aria-controls="face_picker_popup" title="Pick an emoji" data-default="ðŸ™‚">ðŸ™‚</button>
              </span>
            </label>
          {% endif %}
        </div>
      {% endwith %}
    {% endif %}
  </div>
  <div class="form-row">
    {% if not user.is_authenticated %}
      <label class="sr-only" for="note_author">Author (optional)</label>
      <input type="text" id="note_author" name="author" placeholder="Your name (optional)" maxlength="25" autocomplete="off" aria-describedby="author_status">
      <span id="author_status" class="hint" role="alert" style="margin-left:.5rem;"></span>
      <input type="hidden" id="note_device_id" name="device_id" value="{{ device_id|default_if_none:"" }}">
      <label class="remember"><input type="checkbox" id="remember_author"> Remember</label>
    {% else %}
      <input type="hidden" id="note_device_id" name="device_id" value="{{ device_id|default_if_none:"" }}">
      <p class="hint">Posting as <strong>{{ user.username }}</strong></p>
    {% endif %}
    <button type="submit" name="throw">{% if submit_label %}{{ submit_label }}{% else %}Throw{% endif %}</button>
    {% if show_save_draft %}
      <button type="submit" name="save_draft" value="1" formnovalidate>Save as draft</button>
    {% endif %}
    {% if is_edit %}
      <button type="submit" name="save_changes" formnovalidate>Save changes</button>
    {% endif %}
  </div>
  {% if errors %}
    <p class="error">{{ errors }}</p>
  {% endif %}
  <p class="hint">{% if is_edit %}Edit your draft. You can save changes or throw it.{% else %}Public for ~48 hours. Please avoid personal info.{% endif %}</p>
</form>

<style>
  button.face-emoji-btn {
    min-width: 2.2em;
    height: 2.2em;
    line-height: 2.1em;
    font-size: 1.1rem;
    background: var(--card-bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0 0.25em;
    transition: background 0.15s ease, border-color 0.15s ease,
      transform 0.15s ease;
  }
  .face-emoji-btn:hover {
    background: rgba(124, 82, 149, 0.12);
  }
  [data-theme="dark"] .face-emoji-btn:hover {
    background: rgba(176, 133, 212, 0.18);
  }
  .face-emoji-btn:focus {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }
  .face-emoji-btn:active {
    transform: scale(0.92);
  }
  /* Themed emoji picker styles */
  .face-picker-popup {
    z-index: 1000;
    background: var(--card-bg);
    color: var(--ink);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 0.55rem 0.6rem 0.75rem;
    width: 280px;
    max-height: 370px;
    overflow: auto;
    box-shadow: 0 8px 28px -6px rgba(0, 0, 0, 0.25), 0 2px 6px rgba(0, 0, 0, 0.08);
    font-size: 0.95em;
    backdrop-filter: blur(6px);
  }
  [data-theme="dark"] .face-picker-popup {
    box-shadow: 0 10px 34px -8px rgba(0, 0, 0, 0.55),
      0 2px 10px rgba(0, 0, 0, 0.4);
  }
  .face-picker-popup::-webkit-scrollbar {
    width: 8px;
  }
  .face-picker-popup::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 4px;
  }
  .face-picker-popup::-webkit-scrollbar-thumb:hover {
    background: var(--accent);
  }
  .fp-group {
    margin: 0 0 0.35rem;
  }
  .fp-body {
    margin: 0.25rem 0 0.4rem;
    line-height: 1.5;
    text-align: center;
  }
  .fp-item {
    background: none;
    border: none;
    padding: 4px 6px;
    cursor: pointer;
    font-size: 1.25rem;
    line-height: 1.2;
    border-radius: 6px;
    transition: background 0.15s ease, transform 0.15s ease;
  }
  .fp-item:hover {
    background: rgba(124, 82, 149, 0.12);
  }
  [data-theme="dark"] .fp-item:hover {
    background: rgba(176, 133, 212, 0.18);
  }
  .fp-item:focus {
    outline: 2px solid var(--accent);
    outline-offset: 1px;
    background: rgba(124, 82, 149, 0.18);
  }
  [data-theme="dark"] .fp-item:focus {
    background: rgba(176, 133, 212, 0.25);
  }
  .fp-item:active {
    transform: scale(0.92);
  }
  .fp-item.selected {
    background: var(--accent);
    color: #fff;
    box-shadow: 0 0 0 1px var(--accent) inset;
  }
  .face-picker-popup .cat-tabs {
    margin-bottom: 0.4rem;
    display: flex;
    gap: 4px;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  .face-picker-popup .cat-tabs::-webkit-scrollbar {
    display: none;
  }
  .face-picker-popup .cat-tab {
    background: var(--card-bg);
    border: 1px solid var(--border);
    color: var(--muted);
    padding: 4px 8px;
    font-size: 0.7rem;
    line-height: 1.15;
    border-radius: 999px;
    cursor: pointer;
    white-space: nowrap;
    transition: background 0.15s ease, color 0.15s ease, border-color 0.15s ease;
  }
  .face-picker-popup .cat-tab:hover {
    color: var(--ink);
    background: rgba(124, 82, 149, 0.12);
  }
  [data-theme="dark"] .face-picker-popup .cat-tab:hover {
    background: rgba(176, 133, 212, 0.18);
    color: var(--ink);
  }
  .face-picker-popup .cat-tab[aria-selected="true"] {
    background: var(--accent);
    color: #fff;
    border-color: var(--accent);
  }
  .face-picker-popup .fp-toolbar {
    background: linear-gradient(to right, rgba(124, 82, 149, 0.08), transparent);
    padding: 0.25rem 0.4rem 0.4rem;
    border-radius: 6px;
    display: flex;
    gap: 0.5rem;
    align-items: center;
    margin: 0 0 0.4rem;
  }
  [data-theme="dark"] .face-picker-popup .fp-toolbar {
    background: linear-gradient(to right, rgba(176, 133, 212, 0.14), transparent);
  }
  .face-picker-popup .fp-search {
    flex: 1;
    background: var(--card-bg);
    border: 1px solid var(--border);
    color: var(--ink);
    padding: 6px 8px;
    border-radius: 6px;
    font-size: 0.8rem;
  }
  .face-picker-popup .fp-search:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(124, 82, 149, 0.18);
  }
  [data-theme="dark"] .face-picker-popup .fp-search:focus {
    box-shadow: 0 0 0 2px rgba(176, 133, 212, 0.25);
  }
  .face-picker-popup.mobile {
    width: 100%;
    max-height: 60vh;
    left: 0 !important;
    right: 0;
    top: auto !important;
    bottom: 0;
    border-radius: 18px 18px 0 0;
    padding: 0.75rem 0.85rem 1rem;
    box-shadow: 0 -4px 24px -2px rgba(0, 0, 0, 0.45);
  }
  .face-picker-popup.mobile .fp-item {
    font-size: 1.5rem;
    padding: 8px 8px;
  }
  .face-picker-backdrop {
    position: fixed;
    inset: 0;
    backdrop-filter: blur(2px);
    z-index: 999;
    display: none;
    background: radial-gradient(
      circle at 30% 40%,
      rgba(0, 0, 0, 0.35),
      rgba(0, 0, 0, 0.55)
    );
  }
  .face-picker-backdrop.show {
    display: block;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0 0 0 0);
    white-space: nowrap;
    border: 0;
  }
  @media (max-width: 520px) {
    .face-picker-popup {
      width: 90vw;
    }
  }
  @media (max-width: 640px) {
    .face-picker-popup {
      font-size: 1.05em;
    }
    .face-picker-popup:not(.mobile) .fp-item {
      font-size: 1.2rem;
    }
  }
</style>

<script>
  // --- Emoji picker popup (moved from index.html for shared use)
  (function() {
    const btn = document.getElementById('face_display_btn');
    const input = document.getElementById('xp_status_cafe_face');
    if (!btn || !input) return;

    // Status.cafe curated sets extracted from live site markup
    const groups = [
      { name: 'Feelings', id: 'feelings', items: [
        'ðŸ™‚','ðŸ˜Ž','ðŸ˜›','ðŸ¥°','ðŸ˜‚','â¤ï¸','ðŸ’”','ðŸ˜‡','ðŸ‘½','ðŸ˜±','ðŸ˜­','ðŸ¥¹','ðŸ¤”','ðŸ§','ðŸ˜¶','ðŸ˜¯','ðŸ¤’','ðŸ˜¡','ðŸ¥º','ðŸ¥±','ðŸ¥³','ðŸ¤–','ðŸ’€','ðŸ˜´','ðŸ™ƒ','ðŸ¤','ðŸ¤©','ðŸ‘€','ðŸ”¥','â„ï¸','âœ¨','ðŸ’¡','ðŸŒ§ï¸','ðŸŒ™','ðŸŒˆ','ðŸ’¤','ðŸ¶','ðŸ±','â˜€ï¸'
      ]},
      { name: 'Food & drinks', id: 'food', items: [
        'ðŸ±','ðŸ•','ðŸ”','ðŸ¥—','ðŸ«','ðŸ™','ðŸ¿','ðŸ£','ðŸŒ®','ðŸ','ðŸž','ðŸ§€','ðŸ¦','ðŸ§‹','ðŸ¶','ðŸ·','ðŸ¥ƒ','ðŸ¸','ðŸ¾','ðŸº','ðŸ«–','â˜•ï¸'
      ]},
      { name: 'Activities', id: 'activities', items: [
        'ðŸ“š','ðŸŽ','ðŸ“°','âœ…','âœï¸','â›µ','ðŸ’»','âœˆï¸','ðŸš„','ðŸŒ±','ðŸ’¾','ðŸ“±','ðŸ“–','ðŸ›¹','ðŸ›¼','ðŸŽ¨','ðŸŽ¬','ðŸŽ¤','ðŸŽ®','ðŸŽ·','ðŸ“º','ðŸŽ¶','ðŸŽ²','ðŸ†','â›³ï¸','ðŸŽ±','ðŸ‚'
      ]}
    ];

    let popup = document.getElementById('face_picker_popup');
    let backdrop = document.getElementById('face_picker_backdrop');
    const isMobileLike = () => window.matchMedia('(max-width:700px)').matches;

    function buildPopup() {
      if (popup) return;
      backdrop = document.createElement('div');
      backdrop.id = 'face_picker_backdrop';
      backdrop.className = 'face-picker-backdrop';
      document.body.appendChild(backdrop);

      popup = document.createElement('div');
      popup.id = 'face_picker_popup';
      popup.setAttribute('role', 'dialog');
      popup.setAttribute('aria-modal', 'true');
      popup.setAttribute('aria-label', 'Choose emoji');
      popup.className = 'face-picker-popup';
      popup.style.display = 'none';
      popup.setAttribute('aria-labelledby', 'face_display_btn');

      const tabs = `<nav class="cat-tabs" role="tablist">${groups.map((g,i)=>`<button type="button" role="tab" class="cat-tab" data-target="${g.id}" aria-selected="${i===0?'true':'false'}" tabindex="${i===0?'0':'-1'}">${g.name}</button>`).join('')}</nav>`;
      const search = `<div class="fp-toolbar"><input type="search" placeholder="Searchâ€¦" class="fp-search" aria-label="Search emoji"></div>`;
      const bodies = groups.map((g,i)=>`
        <section class="fp-group" data-group="${g.id}" ${i!==0?'hidden':''}>
          <h3 class="sr-only">${g.name}</h3>
          <div class="fp-body" role="group" aria-label="${g.name} emojis">
            ${g.items.map(e => `<button type="button" class="fp-item" data-e="${e}" tabindex="-1">${e}</button>`).join(' ')}
          </div>
        </section>`).join('\n');
      popup.innerHTML = `${search}${tabs}<div class="fp-scroller">${bodies}</div>`;
      document.body.appendChild(popup);
    }
    buildPopup();

    function refreshMobileClass() {
      if (!popup) return;
      if (isMobileLike()) popup.classList.add('mobile'); else popup.classList.remove('mobile');
    }
    refreshMobileClass();
    window.addEventListener('resize', refreshMobileClass);

    // Position popup under/near button â€” clamp to viewport so it never overflows offscreen
    function position() {
      if (popup.classList.contains('mobile')) {
        popup.style.position = 'fixed';
        popup.style.top = 'auto';
        popup.style.left = '0';
        popup.style.right = '0';
        popup.style.bottom = '0';
        return;
      }
      try {
        const r = btn.getBoundingClientRect();
        // desired coordinates below the button
        const desiredLeft = Math.round(window.scrollX + r.left);
        const desiredTop = Math.round(window.scrollY + r.bottom + 8); // small gap

        // measure popup size (may be display:none so force measurement by making it visible offscreen)
        let needRestoreDisplay = false;
        const prevDisplay = popup.style.display;
        if (popup.style.display === 'none') {
          popup.style.visibility = 'hidden';
          popup.style.display = 'block';
          needRestoreDisplay = true;
        }
        const pw = popup.offsetWidth || 0;
        const ph = popup.offsetHeight || 0;
        if (needRestoreDisplay) {
          popup.style.display = prevDisplay;
          popup.style.visibility = '';
        }

        const scrollX = window.scrollX || window.pageXOffset || 0;
        const scrollY = window.scrollY || window.pageYOffset || 0;
        const vw = window.innerWidth;
        const vh = window.innerHeight;

        const edgePad = 8; // keep popup a bit inset from viewport edges

        // Clamp left so popup stays within viewport horizontally
        let left = Math.min(
          Math.max(desiredLeft, scrollX + edgePad),
          Math.max(scrollX + vw - pw - edgePad, scrollX + edgePad)
        );

        // Prefer positioning below; if not enough space, try above
        let top = desiredTop;
        const bottomEdge = scrollY + vh - edgePad;
        if (top + ph > bottomEdge) {
          // try above the button
          const topAbove = Math.round(scrollY + r.top - ph - 8);
          if (topAbove >= scrollY + edgePad) {
            top = topAbove;
          } else {
            // clamp vertically so at least part of popup is visible
            top = Math.min(Math.max(desiredTop, scrollY + edgePad), Math.max(scrollY + vh - ph - edgePad, scrollY + edgePad));
          }
        }

        popup.style.position = 'absolute';
        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
      } catch (e) {
        // Fallback to simple placement if anything goes wrong
        const r = btn.getBoundingClientRect();
        popup.style.position = 'absolute';
        popup.style.top = `${Math.round(window.scrollY + r.bottom + 4)}px`;
        popup.style.left = `${Math.round(window.scrollX + r.left)}px`;
      }
    }

    function open() {
      position();
      popup.style.display = 'block';
      if (backdrop) backdrop.classList.add('show');
      btn.setAttribute('aria-expanded', 'true');
      document.addEventListener('mousedown', onDocDown, true);
      document.addEventListener('keydown', onKey);
      const firstTab = popup.querySelector('.cat-tab[aria-selected="true"]');
      if (firstTab) firstTab.focus();
    }
    function close(returnFocus=true) {
      popup.style.display = 'none';
      if (backdrop) backdrop.classList.remove('show');
      btn.setAttribute('aria-expanded', 'false');
      document.removeEventListener('mousedown', onDocDown, true);
      document.removeEventListener('keydown', onKey);
      if (returnFocus) btn.focus();
    }
    function toggle() { popup.style.display === 'none' ? open() : close(); }

    function onDocDown(e) {
      if (popup.contains(e.target) || e.target === btn) return;
      close(false);
    }
    function onKey(e) {
      if (e.key === 'Escape') { close(); }
      // Basic focus trap while open: cycle Tab within popup & button
      if (e.key === 'Tab' && popup.style.display !== 'none') {
        const focusables = [btn, ...popup.querySelectorAll('.fp-item')].filter(el => !el.closest('.fp-body[hidden]'));
        if (!focusables.length) return;
          const idx = focusables.indexOf(document.activeElement);
          let nextIdx = idx;
          if (e.shiftKey) nextIdx = idx <= 0 ? focusables.length - 1 : idx - 1; else nextIdx = idx === focusables.length - 1 ? 0 : idx + 1;
          if (idx === -1) return; // allow initial tab in
          e.preventDefault();
          focusables[nextIdx].focus();
      }
    }
    btn.addEventListener('click', toggle);

    popup.addEventListener('click', function(e) {
      const t = e.target;
      if (t.classList.contains('cat-tab')) {
        const target = t.getAttribute('data-target');
        popup.querySelectorAll('.cat-tab').forEach(tab => {
          const sel = tab === t;
          tab.setAttribute('aria-selected', sel ? 'true':'false');
          tab.tabIndex = sel ? 0 : -1;
        });
        popup.querySelectorAll('.fp-group').forEach(g => {
          if (g.getAttribute('data-group') === target) g.hidden = false; else g.hidden = true;
        });
        // focus first emoji in that group
        const first = popup.querySelector(`.fp-group[data-group="${target}"] .fp-item`);
        if (first) first.focus();
        return;
      }
      if (t.classList.contains('fp-item')) {
        const val = t.getAttribute('data-e');
        input.value = val;
        btn.textContent = val;
        btn.setAttribute('data-selected', val);
        try { localStorage.setItem('aether_xp_status_cafe_face', val); } catch(e) {}
        markSelected(val);
        addRecent(val);
        close();
      }
    });

    // Tab keyboard navigation
    popup.addEventListener('keydown', function(e) {
      const activeTab = document.activeElement.closest && document.activeElement.closest('.cat-tab');
      if (activeTab) {
        const tabs = Array.from(popup.querySelectorAll('.cat-tab'));
        let idx = tabs.indexOf(activeTab);
        if (e.key === 'ArrowRight') { idx = (idx+1)%tabs.length; e.preventDefault(); tabs[idx].click(); tabs[idx].focus(); }
        else if (e.key === 'ArrowLeft') { idx = (idx-1+tabs.length)%tabs.length; e.preventDefault(); tabs[idx].click(); tabs[idx].focus(); }
      }
    }, true);

    // Search filtering (debounced)
    const searchInput = popup.querySelector('.fp-search');
    let searchTimer = null;
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        clearTimeout(searchTimer);
          const qRaw = searchInput.value.trim();
          searchTimer = setTimeout(()=> filterEmojis(qRaw), 120);
      });
    }

    function filterEmojis(q) {
      const qn = q.toLowerCase();
      popup.querySelectorAll('.fp-group').forEach(group => {
        let any = false;
        group.querySelectorAll('.fp-item').forEach(item => {
          const e = item.getAttribute('data-e');
          const show = !qn || e.toLowerCase().includes(qn);
          item.style.display = show ? '' : 'none';
          if (show) any = true;
        });
        group.style.display = any ? '' : 'none';
      });
    }

    // Basic keyboard nav within open body using arrow keys
    popup.addEventListener('keydown', function(e) {
      const current = document.activeElement;
      if (!current || !current.classList.contains('fp-item')) return;
      const visibleItems = Array.from(popup.querySelectorAll('.fp-group:not([hidden]) .fp-item')).filter(it => it.style.display !== 'none');
      const idx = visibleItems.indexOf(current);
      if (idx === -1) return;
      let nextIdx = null;
      const perRow = 8; // heuristic
      if (e.key === 'ArrowRight') nextIdx = idx + 1;
      else if (e.key === 'ArrowLeft') nextIdx = idx - 1;
      else if (e.key === 'ArrowDown') nextIdx = idx + perRow;
      else if (e.key === 'ArrowUp') nextIdx = idx - perRow;
      else if (e.key === 'Home') nextIdx = 0;
      else if (e.key === 'End') nextIdx = visibleItems.length - 1;
      else if (e.key === 'Enter' || e.key === ' ') { current.click(); return; }
      if (nextIdx != null) {
        e.preventDefault();
        if (nextIdx < 0) nextIdx = 0;
        if (nextIdx >= visibleItems.length) nextIdx = visibleItems.length - 1;
        visibleItems[nextIdx].focus();
      }
    });

    function markSelected(val) {
      popup.querySelectorAll('.fp-item.selected').forEach(el => el.classList.remove('selected'));
      if (!val) return;
      const b = popup.querySelector(`.fp-item[data-e="${CSS.escape(val)}"]`);
      if (b) b.classList.add('selected');
    }

    function addRecent(val) {
      if (!val) return;
      try {
        const key = 'aether_face_recent';
        let arr = JSON.parse(localStorage.getItem(key) || '[]');
        arr = arr.filter(v => v !== val);
        arr.unshift(val);
          if (arr.length > 12) arr = arr.slice(0,12);
        localStorage.setItem(key, JSON.stringify(arr));
        renderRecent(arr);
      } catch(e) {}
    }

    function renderRecent(arr) {
      try {
        const key = 'aether_face_recent';
        if (!arr) arr = JSON.parse(localStorage.getItem(key) || '[]');
        if (!arr.length) return; // no recent yet
        let recentGroup = popup.querySelector('.fp-group[data-group="recent"]');
        if (!recentGroup) {
          recentGroup = document.createElement('section');
          recentGroup.className = 'fp-group';
          recentGroup.setAttribute('data-group','recent');
          recentGroup.innerHTML = `<h3 class="sr-only">Recently used</h3><div class="fp-body" role="group" aria-label="Recently used emojis"></div>`;
          const firstGroup = popup.querySelector('.fp-group');
          popup.querySelector('.fp-scroller').insertBefore(recentGroup, firstGroup);
          // Add tab
          const tabsWrap = popup.querySelector('.cat-tabs');
          if (tabsWrap && !tabsWrap.querySelector('[data-target="recent"]')) {
            const btnEl = document.createElement('button');
            btnEl.type='button';
            btnEl.role='tab';
            btnEl.className='cat-tab';
            btnEl.setAttribute('data-target','recent');
            btnEl.setAttribute('aria-selected','false');
            btnEl.tabIndex = -1;
            btnEl.textContent = 'Recent';
            tabsWrap.insertBefore(btnEl, tabsWrap.firstChild);
          }
        }
        const body = recentGroup.querySelector('.fp-body');
        body.innerHTML = arr.map(e => `<button type="button" class="fp-item" data-e="${e}" tabindex="-1">${e}</button>`).join(' ');
      } catch(e) {}
    }

    renderRecent();

    // Initialize selection highlight from stored / current value
    try {
      const stored = localStorage.getItem('aether_xp_status_cafe_face');
      if (stored) {
        input.value = stored;
        btn.textContent = stored;
        btn.setAttribute('data-selected', stored);
      } else {
        const def = btn.getAttribute('data-default') || 'ðŸ™‚';
        input.value = def;
        btn.textContent = def;
      }
      markSelected(input.value);
    } catch(e) {}
  })();
</script>

<script>
  // Shared note-form initialization (counters, device id, author persistence).
  (function() {
    if (window.aetherNoteFormInit) return;
    window.aetherNoteFormInit = true;

    // Author persistence & availability check (no-op if elements missing)
    const authorInput = document.getElementById('note_author');
    const remember = document.getElementById('remember_author');
    const authorStatus = document.getElementById('author_status');
    const submitBtn = document.querySelector('.note-form button[type="submit"]');
    let authorTimer = null;
    let lastQuery = '';

    function setAuthorStatus(msg, cls) {
      if (!authorStatus) return;
      authorStatus.textContent = msg || '';
      authorStatus.className = 'hint ' + (cls || '');
    }

    function checkAuthor() {
      if (!authorInput) return;
      const v = (authorInput.value || '').trim();
      if (!v) {
        setAuthorStatus('', '');
        if (submitBtn) submitBtn.disabled = false;
        return;
      }
      if (v === lastQuery) return;
      lastQuery = v;
      setAuthorStatus('Checkingâ€¦', '');
      fetch(`/accounts/check-username/?u=${encodeURIComponent(v)}`, {
        headers: { 'Accept': 'application/json' }
      }).then(r => r.json().catch(() => ({}))).then(data => {
        if (!data) return;
        if (data.available) {
          setAuthorStatus('OK', 'ok');
          if (submitBtn) submitBtn.disabled = false;
          authorInput.removeAttribute('aria-invalid');
        } else {
          setAuthorStatus('Reserved â€” sign in to use', 'bad');
          if (submitBtn) submitBtn.disabled = true;
          authorInput.setAttribute('aria-invalid', 'true');
        }
      }).catch(() => {});
    }

    if (authorInput && remember) {
      try {
        const saved = localStorage.getItem('aether_author') || '';
        if (saved) {
          authorInput.value = saved;
          remember.checked = true;
        }
      } catch(e) {}
      remember.addEventListener('change', () => {
        if (remember.checked) localStorage.setItem('aether_author', authorInput.value || '');
        else localStorage.removeItem('aether_author');
      });
      authorInput.addEventListener('input', () => {
        if (remember.checked) localStorage.setItem('aether_author', authorInput.value || '');
        clearTimeout(authorTimer);
        authorTimer = setTimeout(checkAuthor, 250);
      });
      // initial check
      checkAuthor();
    }

    // Device id helper and assignment
    function getDeviceId() {
      try {
        let id = localStorage.getItem('aether_device_id');
        if (!id) {
          id = ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
          );
          localStorage.setItem('aether_device_id', id);
        }
        return id;
      } catch(e) {
        return '';
      }
    }
    const deviceField = document.getElementById('note_device_id');
    if (deviceField) {
      deviceField.value = getDeviceId();
    }

    // Textarea placeholder rotation
    const textarea = document.getElementById('note_text');
    if (textarea) {
      try {
        const placeholders = [
          'Go on, throw it into the voidâ€¦',
          "You're not alone, the stars play witness to your thoughts",
        ];
        textarea.placeholder = placeholders[Math.floor(Math.random() * placeholders.length)];
      } catch(e) {}
    }

    // Live character counter and per-network counters
    const counter = document.getElementById('note_counter');
    if (textarea && counter) {
      const max = parseInt(textarea.getAttribute('maxlength') || '2000', 10);
      const update = () => {
        const len = textarea.value.length;
        counter.textContent = `${len}/${max}`;
        const ratio = len / max;
        counter.classList.toggle('near', ratio >= 0.9);

        // Per-network counters
        document.querySelectorAll('.network-counters .char-counter[data-limit]').forEach(el => {
          const lim = parseInt(el.getAttribute('data-limit') || '0', 10);
          if (!lim) return;
          el.textContent = `${len}/${lim}`;
          el.classList.toggle('near', len / lim >= 0.9 && len <= lim);
          el.classList.toggle('over', len > lim);
        });
      };
      textarea.addEventListener('input', update);
      update();
    }

    // Persist per-note crosspost toggles
    function restoreToggle(id, storageKey) {
      const el = document.getElementById(id);
      if (!el) return;
      try {
        const v = localStorage.getItem(storageKey);
        if (v === '0') el.checked = false;
        else if (v === '1') el.checked = true; // explicit
        el.addEventListener('change', () => {
          try { localStorage.setItem(storageKey, el.checked ? '1' : '0'); } catch(e) {}
        });
      } catch(e) {}
    }
    restoreToggle('xp_mastodon', 'aether_xp_mastodon');
    restoreToggle('xp_bluesky', 'aether_xp_bluesky');
    restoreToggle('xp_status_cafe', 'aether_xp_status_cafe');

    // Persist chosen Status.cafe face emoji (safe guard if emoji script already handled it)
    const faceInput = document.getElementById('xp_status_cafe_face');
    if (faceInput) {
      try {
        const savedFace = localStorage.getItem('aether_xp_status_cafe_face');
        if (savedFace) faceInput.value = savedFace;
        faceInput.addEventListener('input', () => {
          const v = (faceInput.value || '').trim();
          if (v.length > 8) faceInput.value = v.slice(0,8);
          try { localStorage.setItem('aether_xp_status_cafe_face', faceInput.value); } catch(e) {}
        });
      } catch(e) {}
    }
  })();
</script>
